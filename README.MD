#刷剑指offer,记录一下

##斐波那契数列  
**问题**：斐波那契数列，青蛙跳  
**思路1**：递归 时间复杂度为O(2^n)不可取   
**思路2**：循环 时间复杂度为O(n)  
---
**问题2**：圆圈中最后剩下的数
**思路1**：使用list模拟循环链表，用cur作为指向list的下标位置。
当cur移到list末尾直接指向list头部，当删除一个数后list的长度和cur的值相等则cur指向0  
**思路2**：递归或循环  f(n)=(f(n-1)+m)%n  

##数组  
**问题1**：二维数组搜索  
**思路1**：暴力法 不考虑题目给的条件，从左至右，从上至下，顺序遍历，复杂度O(mn)  
**思路2**：考虑 题目条件 从左下角开始搜索  
---
**问题2**：替换空格  
**思路1**：作弊法 调用函数replace  
**思路2**：替换法 引入新的列表 遇到空格替换 否则不替换  
---  
**问题3**：数组中出现次数过半的数字  
**思路1**：使用字典，记录每个数组出现的次数dic[num],判断是否大于一半
时间复杂度O(n),空间复杂度O(n)  
**思路2**：每次把两个不同的数取出，剩下最后的数判断其个数是否大于一半。  
---  
**问题4**：寻找第N个丑数（公因子只有2，3，5）  
**思路1**：设置是否为丑数条件，循环N次。  
**思路2**：设置3个指针，当选择某个指针时(最小的数)，指针向前移动一位  
---  
**问题5**：数组中出现次数为1的两个数  
**思路1**：字典 多加空间复杂度O（n）  
**思路2**：运用异或异或,1.a^b^c=c^b^a  满足交换律  2.两个相同数异或值为0
因此，在找到不同的两个数的异或值之后，判断他哪一位不同，就可以把这个数列分为
各包含一个不同数的数列，再使用异或 得到那个数  

##栈  
**问题**：两个栈表示一个队列的进与出  
**思路**：进：直接append  出:注意判断stackB是否为空 把stackA入栈到stackB，B再出栈  
---
**问题**：包含min函数的栈  
**思路**：创建辅助栈  用辅助栈存放较小的元素  
---
**问题**：栈的压入，弹出序列  
**思路**：创建辅助栈 模拟出栈顺序，当辅助栈的头节点与入栈的数值相同时就辅助栈进行出栈操作
最后判断是否辅助栈是否为空  

##查找和排序  
**问题1**：旋转数组的最小问题  
**思路1**：暴力法 遍历 时间复杂度O(n)  
**思路2**：二分法 区别于传统二分法 它分两段进行排序，目标保证最小值位于递增或递减数组中即可
二分法时间复杂度 怎么算O(log(n))  
---
**问题2**：调整数组顺序使奇数排在偶数前面  
**思路**：把奇数偶数拿出来，拼在一起  

##链表  
**问题1**：从尾到头打印链表  
**思路**：从头到尾读取到列表，在reverse()  
---
**问题2**：打印链表倒数第k个节点  
**思路1**：从头到为打印，读取倒数第k个节点  
**思路2**：设置两个指针p1,p2，p2先走k-1个单位，p1再走  
---
**问题3**：反转链表  
**思路1**：设置三个指针赋值  
**思路2**：递归，没看懂  
---
**问题4**：合并两个排序链表  
**思路1**：设置四个指针，第一个为头指针，后三个一次后移即可  
**思路2**：递归 妙啊  
---
**问题5**：复制复杂链表  
**思路**：复制节点插入原点后，复制random指针，拆分  
---
**问题6**：输入两个链表，找出它们的第一个公共结点。  
**思路1**：遍历两个链表 复杂度为O(mn)  
**思路2**：寻找到两个链表的差值，让长的先走，在寻找公共节点，时间复杂度O(n)
---
**问题7**：链表中环的入口节点  
**思路1**：增加空间复杂度，把所有元素放入空列表，如果有相同则返回  
**思路2**：使用两个指针，一个slow走1，fast走2  

##二进制  
**问题1**：二进制中1的个数
**思路1**：注意负数 用python不处理会报错(-1&0xFFFFFFFF),
转化为二进制，如果等于1就count+1
**思路2**：把数与1(1进行左移)进行位与操作，统计count  
---
**问题2**：不用加减乘除，实现加法操作
**思路**：两个数异或：相当于每一位相加，而不考虑进位；两个数相与，并左移一位：相当于求得进位；将上述两步的结果相加 
注意：当输出为负数的时候 进行~(a&0xFFFFFFFF)操作  

##数学逻辑  
**问题1**：从n当中数1出现的次数  
**思路1**：暴力法，存储每个数，需要花费大量的存储空间  
**思路2**：递归法，f(n)=f(n-1)+count(n)，count(n)为n中1的个数  
**思路3**：1 取第  i  位左边（高位）的数字，乘以  10 i−1 ，得到基础值  a 。
2.取第  i  位数字，计算修正值： 如果大于 X，则结果为  a+ 10 i−1 。  
   如果小于 X，则结果为  a 。  
   如果等 X，则取第  i  位右边（低位）数字，设为  b ，最后结果为  a+b+1 。  

##树  
**二叉树思路主要是遍历，找到遍历结束的点。**  

**问题1**：树的前中后遍历  
**思路1**：递归  
**思路2**：循环 直以后续遍历的循环  
---
**问题2**：重建二叉树，已知二叉树前序和中序，求原来二叉树  
**思路**：遍历思想，前序第一个节点是根节点，中序遍历根节点左边是左子树，右边是右子树
，同理，前序遍历的左子树和右子树也能找到，在再左子树和右子树里面进行遍历  
---
**问题2**：树的子结构  
**思路**：遍历，求每个节点相同
